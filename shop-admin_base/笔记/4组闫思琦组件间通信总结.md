# 组件间通信方式

## props（最基本的方式）

- 适用于父子组件之间的通信
- 使用方式：
  - 父组件--->以标签属性方式给子组件传递数据
  - 子组件--->内部声明接收才可以使用
- 传递的数据类型：
  - 父-->子：传递的是非函数类型的属性
  - 子-->父：传递的是函数类型的属性

## vue自定义事件

- 适用于子向父组件通信，功能相当于函数类型的props
- 事件包括原生dom事件和vue自定义事件
  - 原生dom事件
    - 绑定原生dom事件的2种情况？
      - 1.在html标签上绑定dom事件名的监听  
      - 2.在组件标签上dom事件名的监听（事件名绑定在根标签上）
      - 当用户操作对应界面是，浏览器自动创建并封闭包含相关数据的事件对象，分发对应事件，触发事件监听，调用回调函数
        - 事件对象event本质是：事件数据对象
          - event对象的数据属性：target / offsetX / offsetY / keyCode等
          - $event是浏览器创建的对象，他会默认传递给事件监听的回调函数  
  - vue自定义事件
    - 绑定vue自定义事件监听？
      - 1.只能在组件标签上绑定
      - 2.事件名任意，可以与原生dom事件名相同
      - 只当执行$emit('自定义事件名', data)时分发自定义事件, 才会触发自定义事件监听函数调用
        - $event:分发自定义事件是指定的data数据（可以是任意类型，也可以没）

## 全局事件总线

- 适用于各种组件之间的通信
- 总线对象的原型对象是Vue的实例对象（vm对象）：组件对象可以直接访问Vue原型上的方法。
- 实现过程：1.指定总线对象`beforeCreate() {
                    Vue.prototype.$bus = this
                }`
            2.分发事件/出阿迪数据的组件：`this.$bus.$emit('eventName', data)`
            3.处理时间按/接收数据的组件：`this.$bus.$on('eventName', (data) => {})`

## 消息订阅发布机制

- 适用于任意组件之间的通信
- 使用之前引入第三方库：PubSubJS -->`import PubSub from 'pubsub-js'  `
- 相关API：
  - 订阅消息： `PubSub.subscribe(‘msgName’, functon(msgName, data)`
  - 发布订阅消息触发订阅的函数调用：`PubSub.publish(‘msgName’, data)`
  - 取消订阅：`PubSub.unsubscribe(token/msgName)`

## 插槽（solt）

- 适用于父组件向子组件传递标签结构内容的数据，但是数据在子组件中
- 使用：
  - 如果有确定结构的标签数据使用默认插槽或者具名插槽
  - 如果确定标签结构的数据在子组件，使用作用域插槽
  - 如果有一个不确定的标签结构使用默认插槽
  - 如果有多个不确定的标签结构使用具名插槽
- 编码：
  - 子组件：`<slot :row="item" :$index="index">  <!-- slot的属性会自动传递给父组件 -->`
  - 父组件:`<template slot-scope="{row, $index}"><span>{{$index+1}}</span> &nbsp;&nbsp;<span :style="{color: $index%2===1 ? 'blue' : 'green'}" >{{row.text}}</span></template>`
  - 注意点：使用作用域插槽：更加适用用封装列表之类的组件，
           - 例如：element-ui中: Table组件中就用到了slot-scope

## vuex

- 理解：是对vue应用的多个组件的共享状态数据进行集中式管理
- 适用于任意两个组件之间的通信
  - A组件触发action或mutation调用, 将数据保存到vuex的状态中
  - B组件读取vuex中的state或getters数据, 得到最新保存的数据进行显示

## 组件间通信高级

### v-model

- v-model的本质：
  - 在原生input上的v-model的本质：动态的value属性和原生input事件监听
    - 例如：`<input type="text" :value="name2" @input="name2=$event.target.value">`  
  - 在组件标签上的v-model的本质：动态的value属性和自定义input事件监听
    - 例如：
      - 父组件：`<CustomInput :value="name4" @input="name4=$event"/>`
      - 子组件 :`props: ['value']<input type="text" :value="value" @input="$emit('input', $event.target.value)">`
- v-model作用？
  - 可以实现原生标签的双向数据绑定
  - 可以实现组件标签的双向数据绑定 
  - 可以实现父子组件间数据的双向同步
- v-model一般用于封装带表单项的复用性组件。
  - 例如：` elment-ui中: Input/CheckBox/Radio/Select等表单项组件都封装了v-model`

### 属性修饰符sync

- sync本质：绑定自定义事件监听，来接收子分组分发事假携带的罪行数据，来更新父组件的数据
  - 例如:` <child :money.sync="total"/><Child :money="total" @update:money="total=$event"/>` 
- sync的作用？
  - 实现父子组件的数据双向同步，常用于封装可复用组件（跟新父组件数据）
    - 例如: element-ui中: Dialog就利用sync来实现组件的隐藏
- v-model/sync的区别？
  - v-model用于带表单项标签的组件
  - syn用于不带表单项标签的组件 

### $attrs与$listeners

- $attrs:排除props声明, class, style的所有组件标签属性组成的对象
- $listeners:级组件标签绑定的所有自定义事件监听的对象
- v-bind：强制数据绑定,特殊用法：`<div v-bind="{ id: someProp, 'other-attr': otherProp }"></div>`
- v-on：绑定事件的特殊用法：`<button v-on="{ mousedown: doThis, mouseup: doThat }"></button>`
- 两种组合使用？
  - v-bind与$attrs配合使用
  - v-on与$listeners配合使用
- 作用？
  - 封装复用组件时：从父组件中接收不定数量/名称的属性或事件监听，==》在组件内部，传递给他的子组件 
- 扩展双击监听？
  - @dblclick="XXX"
    - 绑定的是自定义事件监听，el-button内部没有处理（没有绑定对应的原生事件监听，没有分发自定义事件），双击不会响应 
  - @dblclick.native="XXX"
    - 绑定的是原生的dom事件监听，最终是给组件的根标签绑定的原生事件监听，因为有事件冒泡，所以当双击a内部的《button》能响应。

### $children与$parent属性

- $children: 所有直接子组件对象的数组, 利用它可以更新多个子组件的数据
- $parent: 父组件对象, 从而可以更新父组件的数据
- $refs: 包含所有有ref属性的标签对象或组件对象的容器对象
- 作用？
  - 能方便得到子组件/父组件/后代组件/父组件/祖辈组件对象，更新data数据或调用其他方法 
- 扩展？
  - 问题：多个组件有部分相同的js代码，实现组件中的代码复用使用：vue的mixin技术解决
  - 使用场景：当多个组件的js配置部分有相同的重复代码时使用
  - mixin的本质：实现vue组件的复用，简化编码 